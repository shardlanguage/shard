from abc import ABC, abstractmethod, abstractproperty

class ProgrammingLanguage(ABC):
    name: str = "unknown"
    file_extension: str = "unknown"
    end_marker: str = ""
    indent_counter: int = 0

    @abstractmethod
    def inline(self, code) -> str: ...

    @abstractmethod
    def preamble(self) -> str: ...

    @abstractmethod
    def main_function(self, f, args) -> str: ...

    @abstractmethod
    def string(self, s) -> str: ...

    @abstractmethod
    def access_array(self, name, idx) -> str: ...

    @abstractmethod
    def access_structure_field(self, instance, field) -> str: ...

    @abstractmethod
    def call_function(self, name, parameters) -> str: ...

    @abstractmethod
    def positive(self, a) -> str: ...

    @abstractmethod
    def negative(self, a) -> str: ...

    @abstractmethod
    def bitwise_not(self, a) -> str: ...

    @abstractmethod
    def logical_not(self, a) -> str: ...

    @abstractmethod
    def sizeof(self, a) -> str: ...

    @abstractmethod
    def add(self, a, b) -> str: ...

    @abstractmethod
    def substract(self, a, b) -> str: ...

    @abstractmethod
    def multiply(self, a, b) -> str: ...

    @abstractmethod
    def divide(self, a, b) -> str: ...

    @abstractmethod
    def modulo(self, a, b) -> str: ...

    @abstractmethod
    def shift_left(self, a, b) -> str: ...

    @abstractmethod
    def shift_right(self, a, b) -> str: ...

    @abstractmethod
    def bitwise_and(self, a, b) -> str: ...

    @abstractmethod
    def bitwise_or(self, a, b) -> str: ...

    @abstractmethod
    def bitwise_xor(self, a, b) -> str: ...

    @abstractmethod
    def is_equal(self, a, b) -> str: ...

    @abstractmethod
    def is_not_equal(self, a, b) -> str: ...

    @abstractmethod
    def is_lesser_than(self, a, b) -> str: ...

    @abstractmethod
    def is_greater_than(self, a, b) -> str: ...

    @abstractmethod
    def is_lesser_than_or_equal(self, a, b) -> str: ...

    @abstractmethod
    def is_greater_than_or_equal(self, a, b) -> str: ...

    @abstractmethod
    def logical_and(self, a, b) -> str: ...

    @abstractmethod
    def logical_or(self, a, b) -> str: ...

    @abstractmethod
    def assign_equal(self, name, val) -> str: ...

    @abstractmethod
    def assign_add(self, name, val) -> str: ...

    @abstractmethod
    def assign_substract(self, name, val) -> str: ...

    @abstractmethod
    def assign_times(self, name, val) -> str: ...

    @abstractmethod
    def assign_divide(self, name, val) -> str: ...

    @abstractmethod
    def assign_modulo(self, name, val) -> str: ...

    @abstractmethod
    def assign_shift_left(self, name, val) -> str: ...

    @abstractmethod
    def assign_shift_right(self, name, val) -> str: ...

    @abstractmethod
    def assign_and(self, name, val) -> str: ...

    @abstractmethod
    def assign_or(self, name, val) -> str: ...

    @abstractmethod
    def assign_xor(self, name, val) -> str: ...

    @abstractmethod
    def assign_not(self, name, val) -> str: ...

    @abstractmethod
    def assign_equal_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_add_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_substract_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_times_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_divide_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_modulo_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_shift_left_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_shift_right_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_and_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_or_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_xor_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_not_array(self, name, idx, val) -> str: ...

    @abstractmethod
    def assign_equal_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_add_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_substract_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_times_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_divide_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_modulo_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_shift_left_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_shift_right_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_and_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_or_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_xor_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def assign_not_field(self, instance, field, val) -> str: ...

    @abstractmethod
    def reference(self, name) -> str: ...

    @abstractmethod
    def cast(self, x, t) -> str: ...

    @abstractmethod
    def group(self, g) -> str: ...

    @abstractmethod
    def declare_variable(self, prefix, name, t, val) -> str: ...

    @abstractmethod
    def declare_array(self, prefix, name, t, length, content) -> str: ...

    @abstractmethod
    def declare_pointer(self, prefix, derefs, name, t, val) -> str: ...

    @abstractmethod
    def declare_empty_variable(self, prefix, name, t) -> str: ...

    @abstractmethod
    def declare_empty_array(self, prefix, name, t, length) -> str: ...

    @abstractmethod
    def declare_extern_symbol(self, symbol) -> str: ...

    @abstractmethod
    def declare_empty_pointer(self, prefix, derefs, name, t) -> str: ...

    @abstractmethod
    def codeblock(self, content) -> str: ...

    @abstractmethod
    def conditional_if(self, condition, branch) -> str: ...

    @abstractmethod
    def conditional_else_if(self, condition, branch) -> str: ...

    @abstractmethod
    def conditional_else(self, branch) -> str: ...

    @abstractmethod
    def infinite_loop(self, branch) -> str: ...

    @abstractmethod
    def while_loop(self, condition, branch) -> str: ...

    @abstractmethod
    def until_loop(self, condition, branch) -> str: ...

    @abstractmethod
    def break_loop(self) -> str: ...

    @abstractmethod
    def continue_loop(self) -> str: ...

    @abstractmethod
    def return_function(self, value) -> str: ...

    @abstractmethod
    def return_function_empty(self) -> str: ...

    @abstractmethod
    def define_function(self, t, name, parameters, body) -> str: ...

    @abstractmethod
    def define_structure(self, name, body) -> str: ...