from shardc.backend.codegen.lang import ProgrammingLanguage

class LangC(ProgrammingLanguage):
    def __init__(self):
        self.name = "C"
        self.file_extension = ".c"
        self.end_marker = ";"
        self.indent_counter = 0

    def inline(self, code) -> str:
        return f"{code}"

    def preamble(self) -> str:
        return '\n'.join([
            "/*",
            "\tThis program has been generated by the shardc compiler.",
            "\tDO NOT EDIT!",
            "*/",
            "",
            "#include <stdint.h>",
            "#include <stddef.h>",
            ""
        ])

    def main_function(self, f, args) -> str:
        args_ = ','.join(args)
        arg_names = "argc, argv" if args else ""
        return f"int main({args_}) {{\n\t{f}({arg_names});\n\treturn 0;\n}}"

    def string(self, s) -> str:
        return f'"{s}"'

    def access_array(self, name, idx) -> str:
        return f"{name}[{idx}]"

    def access_structure_field(self, instance, field) -> str:
        return f"{instance}.{field}"

    def call_function(self, name, parameters) -> str:
        return f"{name}({','.join([p for p in parameters])})"

    def positive(self, a) -> str:
        return f"(+{a})"

    def negative(self, a) -> str:
        return f"(-{a})"

    def bitwise_not(self, a) -> str:
        return f"(~{a})"

    def logical_not(self, a) -> str:
        return f"(!{a})"

    def sizeof(self, a) -> str:
        return f"(sizeof({a}))"

    def add(self, a, b) -> str:
        return f"{a} + {b}"

    def substract(self, a, b) -> str:
        return f"{a} - {b}"

    def multiply(self, a, b) -> str:
        return f"{a} * {b}"

    def divide(self, a, b) -> str:
        return f"{a} / {b}"

    def modulo(self, a, b) -> str:
        return f"{a} % {b}"

    def shift_left(self, a, b) -> str:
        return f"{a} << {b}"
    
    def shift_right(self, a, b) -> str:
        return f"{a} >> {b}"

    def bitwise_and(self, a, b) -> str:
        return f"{a} & {b}"

    def bitwise_or(self, a, b) -> str:
        return f"{a} | {b}"

    def bitwise_xor(self, a, b) -> str:
        return f"{a} ^ {b}"

    def is_equal(self, a, b) -> str:
        return f"{a} == {b}"

    def is_not_equal(self, a, b) -> str:
        return f"{a} != {b}"

    def is_lesser_than(self, a, b) -> str:
        return f"{a} < {b}"

    def is_greater_than(self, a, b) -> str:
        return f"{a} > {b}"

    def is_lesser_than_or_equal(self, a, b) -> str:
        return f"{a} <= {b}"

    def is_greater_than_or_equal(self, a, b) -> str:
        return f"{a} >= {b}"

    def logical_and(self, a, b) -> str:
        return f"{a} && {b}"

    def logical_or(self, a, b) -> str:
        return f"{a} || {b}"

    def assign_equal(self, name, val) -> str:
        return f"{name} = {val}"

    def assign_add(self, name, val) -> str:
        return f"{name} += {val}"

    def assign_substract(self, name, val) -> str:
        return f"{name} -= {val}"

    def assign_times(self, name, val) -> str:
        return f"{name} *= {val}"

    def assign_divide(self, name, val) -> str:
        return f"{name} /= {val}"

    def assign_modulo(self, name, val) -> str:
        return f"{name} %= {val}"

    def assign_shift_left(self, name, val) -> str:
        return f"{name} <<= {val}"

    def assign_shift_right(self, name, val) -> str:
        return f"{name} >>= {val}"

    def assign_and(self, name, val) -> str:
        return f"{name} &= {val}"

    def assign_or(self, name, val) -> str:
        return f"{name} |= {val}"

    def assign_xor(self, name, val) -> str:
        return f"{name} ^= {val}"

    def assign_not(self, name, val) -> str:
        return f"{name} = ~{val}"

    def assign_equal_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] = {val}"

    def assign_add_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] += {val}"

    def assign_substract_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] -= {val}"

    def assign_times_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] *= {val}"

    def assign_divide_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] /= {val}"

    def assign_modulo_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] %= {val}"

    def assign_shift_left_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] <<= {val}"

    def assign_shift_right_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] >>= {val}"

    def assign_and_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] &= {val}"

    def assign_or_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] |= {val}"

    def assign_xor_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] ^= {val}"

    def assign_not_array(self, name, idx, val) -> str:
        return f"{name}[{idx}] = ~{val}"

    def assign_equal_field(self, instance, field, val) -> str:
        return f"{instance}.{field} = {val}"

    def assign_add_field(self, instance, field, val) -> str:
        return f"{instance}.{field} += {val}"

    def assign_substract_field(self, instance, field, val) -> str:
        return f"{instance}.{field} -= {val}"

    def assign_times_field(self, instance, field, val) -> str:
        return f"{instance}.{field} *= {val}"

    def assign_divide_field(self, instance, field, val) -> str:
        return f"{instance}.{field} /= {val}"

    def assign_modulo_field(self, instance, field, val) -> str:
        return f"{instance}.{field} %= {val}"

    def assign_shift_left_field(self, instance, field, val) -> str:
        return f"{instance}.{field} <<= {val}"

    def assign_shift_right_field(self, instance, field, val) -> str:
        return f"{instance}.{field} >>= {val}"

    def assign_and_field(self, instance, field, val) -> str:
        return f"{instance}.{field} &= {val}"

    def assign_or_field(self, instance, field, val) -> str:
        return f"{instance}.{field} |= {val}"

    def assign_xor_field(self, instance, field, val) -> str:
        return f"{instance}.{field} ^= {val}"

    def assign_not_field(self, instance, field, val) -> str:
        return f"{instance}.{field} = ~{val}"

    def reference(self, name) -> str:
        return f"&{name}"

    def cast(self, x, t) -> str:
        return f"({t})({x})"

    def group(self, g) -> str:
        return f"({g})"

    def declare_variable(self, prefix, name, t, val) -> str:
        return f"{prefix} {t} {name} = {val}"

    def declare_array(self, prefix, name, t, length, content) -> str:
        return f"{prefix} {t} {name}[{length}] = {{ {', '.join(content)} }}"

    def declare_pointer(self, prefix, derefs, name, t, val) -> str:
        return f"{prefix} {t} {'*'*derefs}{name} = {val}"

    def declare_empty_variable(self, prefix, name, t) -> str:
        return f"{prefix} {t} {name}"

    def declare_empty_array(self, prefix, name, t, length) -> str:
        return f"{prefix} {t} {name}[{length}]"

    def declare_empty_pointer(self, prefix, derefs, name, t) -> str:
        return f"{prefix} {t} {'*'*derefs}{name}"

    def declare_extern_symbol(self, symbol) -> str:
        return f"extern {symbol}"

    def codeblock(self, content) -> str:
        block = '{\n'
        self.indent_counter += 1
        for stmt in content:
            block += f"{'\t'*self.indent_counter}{stmt}{self.end_marker}\n"
        self.indent_counter -= 1
        block += f'{'\t'*self.indent_counter}' + '}'
        return block

    def conditional_if(self, condition, branch) -> str:
        return f"if ({condition}) {branch}"

    def conditional_else_if(self, condition, branch) -> str:
        return f"else if ({condition}) {branch}"

    def conditional_else(self, branch) -> str:
        return f"else {branch}"

    def infinite_loop(self, branch) -> str:
        return f"while (1) {branch}"

    def while_loop(self, condition, branch) -> str:
        return f"while ({condition}) {branch}"

    def until_loop(self, condition, branch) -> str:
        return f"while (!({condition})) {branch}"

    def for_loop(self, decl, check, update, branch) -> str:
        return f"for ({decl}; {check}; {update}) {branch}"

    def break_loop(self) -> str:
        return "break"

    def continue_loop(self) -> str:
        return "continue"

    def return_function(self, value) -> str:
        return f"return {value}"

    def return_function_empty(self) -> str:
        return "return"

    def define_function(self, t, name, parameters, body) -> str:
        return f"{t} {name}({','.join([p for p in parameters])}) {body}"

    def define_structure(self, name, body) -> str:
        return f"struct {name} {body}"